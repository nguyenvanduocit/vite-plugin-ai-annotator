/**
 * ⚠️  DO NOT EDIT THIS FILE - IT IS AUTO-GENERATED ⚠️
 *
 * Auto-generated server RPC from define.ts
 *
 * Usage:
 *   const server = createRpcServer(socket);
 *   server.handle.eventName(async (data) => { ... });
 *   server.client.methodName(args);
 *   server.dispose();
 *
 * To regenerate: bunx socketrpc-gen /Volumes/Data/Projects/instantcode/app/src/rpc/define.ts
 */

import type { Socket } from "socket.io";
import type { RpcError } from "./types.generated";
import type { BrowserSession, PageContext, ElementData, SelectionResult, ScreenshotResult, InjectResult, ConsoleEntry } from "./define";

// === RPCSERVER INTERFACE ===
/** Handler registration methods - implement these to handle calls from client */
export interface RpcServerHandle {
    /** Register handler for 'getSessions' - called by client */
    getSessions: (handler: () => Promise<BrowserSession[] | RpcError>) => void;
    /** Register handler for 'ping' - called by client */
    ping: (handler: () => Promise<string | RpcError>) => void;
    /** Register handler for RPC errors */
    rpcError: (handler: (error: RpcError) => void) => void;
}

/** Methods to call client */
export interface RpcServerClient {
    /** Call client's 'getPageContext' method */
    getPageContext: (timeout?: number) => Promise<PageContext | RpcError>;
    /** Call client's 'getSelectedElements' method */
    getSelectedElements: (timeout?: number) => Promise<ElementData[] | RpcError>;
    /** Call client's 'triggerSelection' method */
    triggerSelection: (mode: "inspect" | "selector", selector: string | undefined, selectorType: "css" | "xpath" | undefined, timeout?: number) => Promise<SelectionResult | RpcError>;
    /** Call client's 'captureScreenshot' method */
    captureScreenshot: (type: "viewport" | "element", selector: string | undefined, quality: number | undefined, timeout?: number) => Promise<ScreenshotResult | RpcError>;
    /** Call client's 'clearSelection' method */
    clearSelection: () => void;
    /** Call client's 'injectCSS' method */
    injectCSS: (css: string, timeout?: number) => Promise<InjectResult | RpcError>;
    /** Call client's 'injectJS' method */
    injectJS: (code: string, timeout?: number) => Promise<InjectResult | RpcError>;
    /** Call client's 'getConsole' method */
    getConsole: (clear: boolean | undefined, timeout?: number) => Promise<ConsoleEntry[] | RpcError>;
    /** Call client's 'ping' method */
    ping: (timeout?: number) => Promise<string | RpcError>;
}

/** Server RPC interface with ergonomic API. */
/** Use `.handle` to register handlers, `.client` to call client methods, and `.dispose()` to cleanup. */
export interface RpcServer {
    /** Register handlers for calls from client */
    readonly handle: RpcServerHandle;
    /** Call client methods */
    readonly client: RpcServerClient;
    /** The underlying socket instance */
    readonly socket: Socket;
    /** Whether this instance has been disposed */
    readonly disposed: boolean;
    /** Cleanup all registered handlers. Call this when done (e.g., in onBeforeUnmount or useEffect cleanup). */
    dispose(): void;
}

// === FACTORY FUNCTION ===
/**
 * Create a server RPC instance.
 *
 * Usage:
 * ```typescript
 * const server = createRpcServer(socket);
 *
 * // Register handlers for calls from client
 * server.handle.getSessions(async (data) => {
 *   // handle event
 * });
 *
 * // Call client methods
 * const result = await server.client.getPageContext();
 *
 * // Cleanup when done
 * server.dispose();
 * ```
 * @param socket The socket instance
 * @returns RpcServer instance with .handle, .client, and .dispose()
 */
export function createRpcServer(socket: Socket): RpcServer {
    const unsubscribers: Array<() => void> = [];
    let _disposed = false;

    const checkDisposed = () => {
        if (_disposed) throw new Error('RpcServer has been disposed');
    };

    const handle: RpcServerHandle = {
        getSessions(handler: () => Promise<BrowserSession[] | RpcError>) {
            checkDisposed();
            const listener = async (callback: (result: BrowserSession[] | RpcError) => void) => {
                try {
                    const result = await handler();
                    callback(result);
                } catch (error) {
                    console.error('[getSessions] Handler error:', error);
                    callback({ message: error instanceof Error ? error.message : String(error), code: 'INTERNAL_ERROR', data: undefined });
                }
            };
            socket.on('getSessions', listener);
            unsubscribers.push(() => socket.off('getSessions', listener));
        },
        ping(handler: () => Promise<string | RpcError>) {
            checkDisposed();
            const listener = async (callback: (result: string | RpcError) => void) => {
                try {
                    const result = await handler();
                    callback(result);
                } catch (error) {
                    console.error('[ping] Handler error:', error);
                    callback({ message: error instanceof Error ? error.message : String(error), code: 'INTERNAL_ERROR', data: undefined });
                }
            };
            socket.on('ping', listener);
            unsubscribers.push(() => socket.off('ping', listener));
        },
        rpcError(handler: (error: RpcError) => void) {
            checkDisposed();
            const listener = (error: RpcError) => handler(error);
            socket.on('rpcError', listener);
            unsubscribers.push(() => socket.off('rpcError', listener));
        }
    };

    const client: RpcServerClient = {
        async getPageContext(timeout: number = 5000): Promise<PageContext | RpcError> {
            try {
                return await socket.timeout(timeout).emitWithAck('getPageContext');
            } catch (err) {
                return { message: err instanceof Error ? err.message : String(err), code: 'INTERNAL_ERROR', data: undefined };
            }
        },
        async getSelectedElements(timeout: number = 5000): Promise<ElementData[] | RpcError> {
            try {
                return await socket.timeout(timeout).emitWithAck('getSelectedElements');
            } catch (err) {
                return { message: err instanceof Error ? err.message : String(err), code: 'INTERNAL_ERROR', data: undefined };
            }
        },
        async triggerSelection(mode: "inspect" | "selector", selector: string | undefined, selectorType: "css" | "xpath" | undefined, timeout: number = 5000): Promise<SelectionResult | RpcError> {
            try {
                return await socket.timeout(timeout).emitWithAck('triggerSelection', mode, selector, selectorType);
            } catch (err) {
                return { message: err instanceof Error ? err.message : String(err), code: 'INTERNAL_ERROR', data: undefined };
            }
        },
        async captureScreenshot(type: "viewport" | "element", selector: string | undefined, quality: number | undefined, timeout: number = 5000): Promise<ScreenshotResult | RpcError> {
            try {
                return await socket.timeout(timeout).emitWithAck('captureScreenshot', type, selector, quality);
            } catch (err) {
                return { message: err instanceof Error ? err.message : String(err), code: 'INTERNAL_ERROR', data: undefined };
            }
        },
        clearSelection() {
            socket.emit('clearSelection');
        },
        async injectCSS(css: string, timeout: number = 5000): Promise<InjectResult | RpcError> {
            try {
                return await socket.timeout(timeout).emitWithAck('injectCSS', css);
            } catch (err) {
                return { message: err instanceof Error ? err.message : String(err), code: 'INTERNAL_ERROR', data: undefined };
            }
        },
        async injectJS(code: string, timeout: number = 5000): Promise<InjectResult | RpcError> {
            try {
                return await socket.timeout(timeout).emitWithAck('injectJS', code);
            } catch (err) {
                return { message: err instanceof Error ? err.message : String(err), code: 'INTERNAL_ERROR', data: undefined };
            }
        },
        async getConsole(clear: boolean | undefined, timeout: number = 5000): Promise<ConsoleEntry[] | RpcError> {
            try {
                return await socket.timeout(timeout).emitWithAck('getConsole', clear);
            } catch (err) {
                return { message: err instanceof Error ? err.message : String(err), code: 'INTERNAL_ERROR', data: undefined };
            }
        },
        async ping(timeout: number = 5000): Promise<string | RpcError> {
            try {
                return await socket.timeout(timeout).emitWithAck('ping');
            } catch (err) {
                return { message: err instanceof Error ? err.message : String(err), code: 'INTERNAL_ERROR', data: undefined };
            }
        }
    };

    return {
        handle,
        client,
        get socket() { return socket; },
        get disposed() { return _disposed; },
        dispose() {
            if (_disposed) return;
            _disposed = true;
            unsubscribers.forEach(fn => fn());
            unsubscribers.length = 0;
        }
    };
}
